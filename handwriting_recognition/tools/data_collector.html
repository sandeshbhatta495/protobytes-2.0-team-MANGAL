<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwriting Data Collector</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .canvas-container {
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0;
        }
        canvas {
            display: block;
            cursor: crosshair;
            background: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        .btn-primary:hover {
            background: #45a049;
        }
        .btn-secondary {
            background: #2196F3;
            color: white;
        }
        .btn-secondary:hover {
            background: #1976D2;
        }
        .btn-danger {
            background: #f44336;
            color: white;
        }
        .btn-danger:hover {
            background: #d32f2f;
        }
        input[type="text"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            width: 200px;
        }
        .sample-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 6px;
        }
        .sample-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .sample-item:last-child {
            border-bottom: none;
        }
        .sample-label {
            font-family: monospace;
            font-size: 18px;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin: 10px 0;
        }
        .stat {
            text-align: center;
            padding: 10px 20px;
            background: #f0f0f0;
            border-radius: 6px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        .char-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 5px;
            margin: 10px 0;
        }
        .char-btn {
            padding: 10px;
            font-size: 20px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .char-btn:hover {
            background: #e3f2fd;
        }
        .char-btn.selected {
            background: #2196F3;
            color: white;
            border-color: #2196F3;
        }
    </style>
</head>
<body>
    <h1>‚úèÔ∏è Handwriting Data Collector</h1>
    
    <div class="container">
        <h3>Character to Write</h3>
        <div style="display:flex; gap:10px; align-items:center;">
            <input type="text" id="labelInput" placeholder="Enter label" maxlength="10">
            <span style="font-size:24px; padding:10px;" id="currentChar">-</span>
        </div>
        
        <h4>Quick Select (Nepali)</h4>
        <div class="char-grid" id="nepaliChars">
            <!-- Populated by JS -->
        </div>
        
        <h4>Quick Select (English)</h4>
        <div class="char-grid" id="englishChars">
            <!-- Populated by JS -->
        </div>
    </div>
    
    <div class="container">
        <h3>Draw Here</h3>
        <div class="canvas-container">
            <canvas id="drawCanvas" width="400" height="200"></canvas>
        </div>
        <div class="controls">
            <button class="btn-primary" onclick="saveSample()">üíæ Save Sample</button>
            <button class="btn-secondary" onclick="clearCanvas()">üóëÔ∏è Clear</button>
            <button class="btn-danger" onclick="undoLast()">‚Ü©Ô∏è Undo Stroke</button>
        </div>
    </div>
    
    <div class="container">
        <h3>Collected Samples</h3>
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="totalSamples">0</div>
                <div class="stat-label">Total Samples</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="uniqueChars">0</div>
                <div class="stat-label">Unique Characters</div>
            </div>
        </div>
        <div class="controls">
            <button class="btn-primary" onclick="downloadData()">üì• Download JSON</button>
            <button class="btn-secondary" onclick="loadData()">üì§ Load JSON</button>
            <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
        </div>
        <input type="file" id="fileInput" style="display:none" accept=".json">
        <div class="sample-list" id="sampleList">
            <!-- Populated by JS -->
        </div>
    </div>

    <script>
        // Character sets
        const NEPALI_CHARS = '‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø'.split('');
        const ENGLISH_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');

        // State
        let samples = [];
        let currentStrokes = [];
        let currentStroke = [];
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // Canvas setup
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Initialize character buttons
        function initCharButtons() {
            const nepaliGrid = document.getElementById('nepaliChars');
            const englishGrid = document.getElementById('englishChars');
            
            NEPALI_CHARS.forEach(char => {
                const btn = document.createElement('button');
                btn.className = 'char-btn';
                btn.textContent = char;
                btn.onclick = () => selectChar(char);
                nepaliGrid.appendChild(btn);
            });
            
            ENGLISH_CHARS.forEach(char => {
                const btn = document.createElement('button');
                btn.className = 'char-btn';
                btn.textContent = char;
                btn.onclick = () => selectChar(char);
                englishGrid.appendChild(btn);
            });
        }

        function selectChar(char) {
            document.getElementById('labelInput').value = char;
            document.getElementById('currentChar').textContent = char;
            
            // Update button styles
            document.querySelectorAll('.char-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.textContent === char);
            });
            
            clearCanvas();
        }

        // Canvas event handlers
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            startDrawing(e.touches[0]);
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            draw(e.touches[0]);
        });
        canvas.addEventListener('touchend', stopDrawing);

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x;
            lastY = pos.y;
            currentStroke = [[pos.x, pos.y, 1]];
        }

        function draw(e) {
            if (!isDrawing) return;
            const pos = getPos(e);
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            
            currentStroke.push([pos.x, pos.y, 1]);
            lastX = pos.x;
            lastY = pos.y;
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (currentStroke.length > 0) {
                currentStroke[currentStroke.length - 1][2] = 0; // Pen up
                currentStrokes.push([...currentStroke]);
            }
            currentStroke = [];
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            currentStrokes = [];
            currentStroke = [];
        }

        function undoLast() {
            if (currentStrokes.length > 0) {
                currentStrokes.pop();
                redrawCanvas();
            }
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            currentStrokes.forEach(stroke => {
                if (stroke.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(stroke[0][0], stroke[0][1]);
                for (let i = 1; i < stroke.length; i++) {
                    ctx.lineTo(stroke[i][0], stroke[i][1]);
                }
                ctx.stroke();
            });
        }

        function saveSample() {
            const label = document.getElementById('labelInput').value.trim();
            if (!label) {
                alert('Please enter a label first');
                return;
            }
            if (currentStrokes.length === 0) {
                alert('Please draw something first');
                return;
            }

            samples.push({
                strokes: JSON.parse(JSON.stringify(currentStrokes)),
                label: label,
                timestamp: new Date().toISOString()
            });

            updateUI();
            clearCanvas();
        }

        function updateUI() {
            // Update stats
            document.getElementById('totalSamples').textContent = samples.length;
            const uniqueLabels = new Set(samples.map(s => s.label));
            document.getElementById('uniqueChars').textContent = uniqueLabels.size;

            // Update sample list
            const list = document.getElementById('sampleList');
            list.innerHTML = '';
            
            samples.slice().reverse().forEach((sample, idx) => {
                const realIdx = samples.length - 1 - idx;
                const div = document.createElement('div');
                div.className = 'sample-item';
                div.innerHTML = `
                    <span class="sample-label">${sample.label}</span>
                    <span>${sample.strokes.length} strokes</span>
                    <button class="btn-danger" onclick="deleteSample(${realIdx})" style="padding:5px 10px;">&times;</button>
                `;
                list.appendChild(div);
            });
        }

        function deleteSample(idx) {
            samples.splice(idx, 1);
            updateUI();
        }

        function downloadData() {
            if (samples.length === 0) {
                alert('No samples to download');
                return;
            }
            
            const dataStr = JSON.stringify(samples, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `handwriting_data_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function loadData() {
            document.getElementById('fileInput').click();
        }

        document.getElementById('fileInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const loaded = JSON.parse(e.target.result);
                    if (Array.isArray(loaded)) {
                        samples = [...samples, ...loaded];
                        updateUI();
                        alert(`Loaded ${loaded.length} samples`);
                    }
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset
        });

        function clearAll() {
            if (confirm('Are you sure you want to delete all samples?')) {
                samples = [];
                updateUI();
            }
        }

        // Label input sync
        document.getElementById('labelInput').addEventListener('input', e => {
            document.getElementById('currentChar').textContent = e.target.value || '-';
        });

        // Initialize
        initCharButtons();
        updateUI();
    </script>
</body>
</html>
